{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\Omistaja\\\\Downloads\\\\keeper-app-part-2-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Omistaja\\\\Downloads\\\\keeper-app-part-2-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\Omistaja\\\\Downloads\\\\keeper-app-part-2-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Omistaja\\\\Downloads\\\\keeper-app-part-2-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  all: 'all'\n};\nconst VALUE = 'value';\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners({\n  field: {\n    ref\n  },\n  handleChange,\n  isRadioOrCheckbox\n}) {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nvar isArray = value => Array.isArray(value);\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isKey = value => !isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar stringToPath = input => {\n  const result = [];\n  input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, (match, mathNumber, mathQuote, originalString) => {\n    result.push(mathQuote ? originalString.replace(/\\\\(\\\\)?/g, '$1') : mathNumber || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (!isKey(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar isUndefined = val => val === undefined;\n\nvar unique = value => value.filter(Boolean);\n\nvar get = (obj, path, defaultValue) => {\n  const result = unique(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === \"\".concat(SELECT, \"-multiple\");\n\nvar isEmptyString = value => value === '';\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(({\n        ref: {\n          value\n        }\n      }) => value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const _options$0$ref = options[0].ref,\n          checked = _options$0$ref.checked,\n          value = _options$0$ref.value,\n          attributes = _options$0$ref.attributes;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || isEmptyString(value) ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fields, name) {\n  if (fields[name]) {\n    const field = fields[name];\n    const value = field.ref.value,\n          ref = field.ref;\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return field ? getRadioValue(field.options).value : '';\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return field ? getCheckboxValue(field.options).value : false;\n    }\n\n    return value;\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nfunction baseGet(object, updatePath) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return index == length ? object : undefined;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, unmountFieldsStateRef, shouldUnregister, forceDelete) {\n  const ref = field.ref,\n        _field$ref = field.ref,\n        name = _field$ref.name,\n        type = _field$ref.type,\n        mutationWatcher = field.mutationWatcher;\n  const fieldRef = fields[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fields, name);\n\n    if (!isUndefined(value)) {\n      unmountFieldsStateRef.current[name] = value;\n    }\n  }\n\n  if (!type) {\n    delete fields[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const options = fieldRef.options;\n\n    if (isArray(options) && options.length) {\n      unique(options).forEach((option, index) => {\n        const ref = option.ref,\n              mutationWatcher = option.mutationWatcher;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n\n          unset(options, \"[\".concat(index, \"]\"));\n        }\n      });\n\n      if (options && !unique(options).length) {\n        delete fields[name];\n      }\n    } else {\n      delete fields[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fields[name];\n  }\n}\n\nvar isString = value => typeof value === 'string';\n\nvar getFieldsValues = (fields, search) => {\n  const output = {};\n\n  for (const name in fields) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fields, name);\n    }\n  }\n\n  return output;\n};\n\nvar compareObject = (objectA = {}, objectB = {}) => {\n  const objectAKeys = Object.keys(objectA);\n  return objectAKeys.length === Object.keys(objectB).length && objectAKeys.every(key => objectB[key] && objectB[key] === objectA[key]);\n};\n\nvar isSameError = (error, {\n  type,\n  types,\n  message\n}) => isObject(error) && error.type === type && error.message === message && compareObject(error.types, types);\n\nfunction shouldRenderBasedOnError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name)) {\n    return false;\n  }\n\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nconst isValueMessage = value => isObject(value) && !isRegex(value);\n\nvar getValueAndMessage = validationData => isValueMessage(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isBoolean = value => typeof value === 'boolean';\n\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n\n  return {};\n};\n\nvar validateField = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fieldsRef, validateAllFieldCriteria, {\n    ref,\n    ref: {\n      type,\n      value\n    },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate\n  }) {\n    var _a, fields, name, error, isRadio, isCheckBox, isRadioOrCheckbox, isEmpty, appendErrorsCurry, getMinMaxMessage, _ref2, requiredValue, requiredMessage, exceedMax, exceedMin, _getValueAndMessage, maxValue, maxMessage, _getValueAndMessage2, minValue, minMessage, valueNumber, valueDate, _getValueAndMessage3, maxLengthValue, maxLengthMessage, _getValueAndMessage4, minLengthValue, minLengthMessage, inputLength, _getValueAndMessage5, patternValue, patternMessage, fieldValue, validateRef, result, validateError, validationResult, _i, _Object$entries, _Object$entries$_i, key, validateFunction, validateResult;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          fields = fieldsRef.current;\n          name = ref.name;\n          error = {};\n          isRadio = isRadioInput(ref);\n          isCheckBox = isCheckBoxInput(ref);\n          isRadioOrCheckbox = isRadio || isCheckBox;\n          isEmpty = isEmptyString(value);\n          appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n          getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n            const message = exceedMax ? maxLengthMessage : minLengthMessage;\n            error[name] = Object.assign({\n              type: exceedMax ? maxType : minType,\n              message,\n              ref\n            }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n          };\n\n          if (!(required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid))) {\n            _context.next = 15;\n            break;\n          }\n\n          _ref2 = isMessage(required) ? {\n            value: !!required,\n            message: required\n          } : getValueAndMessage(required), requiredValue = _ref2.value, requiredMessage = _ref2.message;\n\n          if (!requiredValue) {\n            _context.next = 15;\n            break;\n          }\n\n          error[name] = Object.assign({\n            type: INPUT_VALIDATION_RULES.required,\n            message: requiredMessage,\n            ref: isRadioOrCheckbox ? (_a = fields[name].options) === null || _a === void 0 ? void 0 : _a[0].ref : ref\n          }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n          if (validateAllFieldCriteria) {\n            _context.next = 15;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 15:\n          if (!(!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n            _context.next = 23;\n            break;\n          }\n\n          _getValueAndMessage = getValueAndMessage(max), maxValue = _getValueAndMessage.value, maxMessage = _getValueAndMessage.message;\n          _getValueAndMessage2 = getValueAndMessage(min), minValue = _getValueAndMessage2.value, minMessage = _getValueAndMessage2.message;\n\n          if (type === 'number' || !type && !isNaN(value)) {\n            valueNumber = ref.valueAsNumber || parseFloat(value);\n\n            if (!isNullOrUndefined(maxValue)) {\n              exceedMax = valueNumber > maxValue;\n            }\n\n            if (!isNullOrUndefined(minValue)) {\n              exceedMin = valueNumber < minValue;\n            }\n          } else {\n            valueDate = ref.valueAsDate || new Date(value);\n\n            if (isString(maxValue)) {\n              exceedMax = valueDate > new Date(maxValue);\n            }\n\n            if (isString(minValue)) {\n              exceedMin = valueDate < new Date(minValue);\n            }\n          }\n\n          if (!(exceedMax || exceedMin)) {\n            _context.next = 23;\n            break;\n          }\n\n          getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n          if (validateAllFieldCriteria) {\n            _context.next = 23;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 23:\n          if (!(isString(value) && !isEmpty && (maxLength || minLength))) {\n            _context.next = 33;\n            break;\n          }\n\n          _getValueAndMessage3 = getValueAndMessage(maxLength), maxLengthValue = _getValueAndMessage3.value, maxLengthMessage = _getValueAndMessage3.message;\n          _getValueAndMessage4 = getValueAndMessage(minLength), minLengthValue = _getValueAndMessage4.value, minLengthMessage = _getValueAndMessage4.message;\n          inputLength = value.toString().length;\n          exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n          exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n          if (!(exceedMax || exceedMin)) {\n            _context.next = 33;\n            break;\n          }\n\n          getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n\n          if (validateAllFieldCriteria) {\n            _context.next = 33;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 33:\n          if (!(pattern && !isEmpty)) {\n            _context.next = 39;\n            break;\n          }\n\n          _getValueAndMessage5 = getValueAndMessage(pattern), patternValue = _getValueAndMessage5.value, patternMessage = _getValueAndMessage5.message;\n\n          if (!(isRegex(patternValue) && !patternValue.test(value))) {\n            _context.next = 39;\n            break;\n          }\n\n          error[name] = Object.assign({\n            type: INPUT_VALIDATION_RULES.pattern,\n            message: patternMessage,\n            ref\n          }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n          if (validateAllFieldCriteria) {\n            _context.next = 39;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 39:\n          if (!validate) {\n            _context.next = 72;\n            break;\n          }\n\n          fieldValue = getFieldValue(fields, name);\n          validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n          if (!isFunction(validate)) {\n            _context.next = 53;\n            break;\n          }\n\n          _context.next = 45;\n          return validate(fieldValue);\n\n        case 45:\n          result = _context.sent;\n          validateError = getValidateError(result, validateRef);\n\n          if (!validateError) {\n            _context.next = 51;\n            break;\n          }\n\n          error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            _context.next = 51;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 51:\n          _context.next = 72;\n          break;\n\n        case 53:\n          if (!isObject(validate)) {\n            _context.next = 72;\n            break;\n          }\n\n          validationResult = {};\n          _i = 0, _Object$entries = Object.entries(validate);\n\n        case 56:\n          if (!(_i < _Object$entries.length)) {\n            _context.next = 68;\n            break;\n          }\n\n          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], validateFunction = _Object$entries$_i[1];\n\n          if (!(!isEmptyObject(validationResult) && !validateAllFieldCriteria)) {\n            _context.next = 60;\n            break;\n          }\n\n          return _context.abrupt(\"break\", 68);\n\n        case 60:\n          _context.next = 62;\n          return validateFunction(fieldValue);\n\n        case 62:\n          validateResult = _context.sent;\n          validateError = getValidateError(validateResult, validateRef, key);\n\n          if (validateError) {\n            validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n            if (validateAllFieldCriteria) {\n              error[name] = validationResult;\n            }\n          }\n\n        case 65:\n          _i++;\n          _context.next = 56;\n          break;\n\n        case 68:\n          if (isEmptyObject(validationResult)) {\n            _context.next = 72;\n            break;\n          }\n\n          error[name] = Object.assign({\n            ref: validateRef\n          }, validationResult);\n\n          if (validateAllFieldCriteria) {\n            _context.next = 72;\n            break;\n          }\n\n          return _context.abrupt(\"return\", error);\n\n        case 72:\n          return _context.abrupt(\"return\", error);\n\n        case 73:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n\n  return function validateField(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\n  const getInnerPath = (value, key, isObject) => {\n    const pathWithIndex = isObject ? \"\".concat(path, \".\").concat(key) : \"\".concat(path, \"[\").concat(key, \"]\");\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return isArray(values) ? values.map((value, key) => getInnerPath(value, key)) : Object.entries(values).map(([key, value]) => getInnerPath(value, key, true));\n};\n\nvar getPath$1 = (parentPath, value) => getPath(parentPath, value).flat(Infinity);\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else if (!isUndefined(fieldValues[fieldName])) {\n    value = fieldValues[fieldName];\n  } else {\n    value = get(transformToNestObject(fieldValues), fieldName);\n\n    if (!isUndefined(value)) {\n      getPath$1(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = ({\n  isOnChange,\n  hasError,\n  isBlurEvent,\n  isOnSubmit,\n  isReValidateOnSubmit,\n  isOnBlur,\n  isReValidateOnBlur,\n  isSubmitted\n}) => isOnChange && isBlurEvent || isOnSubmit && isReValidateOnSubmit || isOnSubmit && !isSubmitted || isOnBlur && !isBlurEvent && !hasError || isReValidateOnBlur && !isBlurEvent && hasError || isReValidateOnSubmit && isSubmitted;\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nvar getFieldValueByName = (fields, name) => {\n  const results = transformToNestObject(getFieldsValues(fields));\n  return name ? get(results, name, results) : results;\n};\n\nfunction getIsFieldsDifferent(referenceArray, differenceArray) {\n  if (!isArray(referenceArray) || !isArray(differenceArray) || referenceArray.length !== differenceArray.length) {\n    return true;\n  }\n\n  for (let i = 0; i < referenceArray.length; i++) {\n    const dataA = referenceArray[i];\n    const dataB = differenceArray[i];\n\n    if (isUndefined(dataB) || Object.keys(dataA).length !== Object.keys(dataB).length) {\n      return true;\n    }\n\n    for (const key in dataA) {\n      if (dataA[key] !== dataB[key]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(\"^\".concat(searchName, \"[\\\\d+]\").replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === \"\".concat(SELECT, \"-one\");\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode\n} = {}) {\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const touchedFieldsRef = useRef({});\n  const fieldArrayDefaultValues = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const dirtyFieldsRef = useRef({});\n  const watchFieldsHookRef = useRef({});\n  const watchFieldsHookRenderRef = useRef({});\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const isValidRef = useRef(true);\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const handleChangeRef = useRef();\n  const unmountFieldsStateRef = useRef({});\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n\n  const _useState = useState(),\n        _useState2 = _slicedToArray(_useState, 2),\n        render = _useState2[1];\n\n  const _useRef$current = useRef(modeChecker(mode)).current,\n        isOnBlur = _useRef$current.isOnBlur,\n        isOnSubmit = _useRef$current.isOnSubmit,\n        isOnChange = _useRef$current.isOnChange,\n        isOnAll = _useRef$current.isOnAll;\n  const validateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const isWindowUndefined = typeof window === UNDEFINED;\n  const isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\n  const isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const _useRef$current2 = useRef(modeChecker(reValidateMode)).current,\n        isReValidateOnBlur = _useRef$current2.isOnBlur,\n        isReValidateOnSubmit = _useRef$current2.isOnSubmit;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  const reRender = useCallback(() => {\n    if (!isUnMount.current) {\n      render({});\n    }\n  }, []);\n  const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\n    let shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: errorsRef.current,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(errorsRef.current, name);\n\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || resolverRef.current) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      errorsRef.current = unset(errorsRef.current, name);\n    } else {\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || !previousError || !isSameError(previousError, error[name]);\n      set(errorsRef.current, name, error[name]);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n      reRender();\n      return true;\n    }\n  }, [reRender, resolverRef]);\n  const setFieldValue = useCallback(({\n    ref,\n    options\n  }, rawValue) => {\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isFileInput(ref)) {\n      if (isString(value)) {\n        ref.value = value;\n      } else {\n        ref.files = value;\n      }\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(({\n        ref: checkboxRef\n      }) => checkboxRef.checked = value.includes(checkboxRef.value)) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, [isWeb]);\n  const setDirty = useCallback(name => {\n    const _readFormStateRef$cur = readFormStateRef.current,\n          isDirty = _readFormStateRef$cur.isDirty,\n          dirtyFields = _readFormStateRef$cur.dirtyFields;\n\n    if (!fieldsRef.current[name] || !isDirty && !dirtyFields) {\n      return false;\n    }\n\n    const isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef.current, name);\n    const isDirtyFieldExist = get(dirtyFieldsRef.current, name);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const previousIsDirty = isDirtyRef.current;\n\n    if (isFieldDirty) {\n      set(dirtyFieldsRef.current, name, true);\n    } else {\n      unset(dirtyFieldsRef.current, name);\n    }\n\n    isDirtyRef.current = isFieldArray && getIsFieldsDifferent(getFieldValueByName(fieldsRef.current, getFieldArrayParentName(name)), get(defaultValuesRef.current, getFieldArrayParentName(name))) || !isEmptyObject(dirtyFieldsRef.current);\n    return isDirty && previousIsDirty !== isDirtyRef.current || dirtyFields && isDirtyFieldExist !== get(dirtyFieldsRef.current, name);\n  }, []);\n  const executeValidation = useCallback( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, skipReRender) {\n      var error;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!fieldsRef.current[name]) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 3;\n            return validateField(fieldsRef, validateAllFieldCriteria, fieldsRef.current[name]);\n\n          case 3:\n            error = _context2.sent;\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n            return _context2.abrupt(\"return\", isEmptyObject(error));\n\n          case 6:\n            return _context2.abrupt(\"return\", false);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n\n    return function (_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [shouldRenderBaseOnError, validateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(payload) {\n      var _yield$resolverRef$cu, errors, previousFormIsValid, isInputsValid, error;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return resolverRef.current(getFieldValueByName(fieldsRef.current), contextRef.current, validateAllFieldCriteria);\n\n          case 2:\n            _yield$resolverRef$cu = _context3.sent;\n            errors = _yield$resolverRef$cu.errors;\n            previousFormIsValid = isValidRef.current;\n            isValidRef.current = isEmptyObject(errors);\n\n            if (!isArray(payload)) {\n              _context3.next = 12;\n              break;\n            }\n\n            isInputsValid = payload.map(name => {\n              const error = get(errors, name);\n\n              if (error) {\n                set(errorsRef.current, name, error);\n              } else {\n                unset(errorsRef.current, name);\n              }\n\n              return !error;\n            }).every(Boolean);\n            reRender();\n            return _context3.abrupt(\"return\", isInputsValid);\n\n          case 12:\n            error = get(errors, payload);\n            shouldRenderBaseOnError(payload, error ? {\n              [payload]: error\n            } : {}, previousFormIsValid !== isValidRef.current);\n            return _context3.abrupt(\"return\", !error);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n\n    return function (_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), [reRender, shouldRenderBaseOnError, validateAllFieldCriteria, resolverRef]);\n  const trigger = useCallback( /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(name) {\n      var fields, result;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            fields = name || Object.keys(fieldsRef.current);\n\n            if (!resolverRef.current) {\n              _context5.next = 3;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", executeSchemaOrResolverValidation(fields));\n\n          case 3:\n            if (!isArray(fields)) {\n              _context5.next = 9;\n              break;\n            }\n\n            _context5.next = 6;\n            return Promise.all(fields.map( /*#__PURE__*/function () {\n              var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return executeValidation(data, true);\n\n                    case 2:\n                      return _context4.abrupt(\"return\", _context4.sent);\n\n                    case 3:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              }));\n\n              return function (_x8) {\n                return _ref6.apply(this, arguments);\n              };\n            }()));\n\n          case 6:\n            result = _context5.sent;\n            reRender();\n            return _context5.abrupt(\"return\", result.every(Boolean));\n\n          case 9:\n            _context5.next = 11;\n            return executeValidation(fields);\n\n          case 11:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 12:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n\n    return function (_x7) {\n      return _ref5.apply(this, arguments);\n    };\n  }(), [executeSchemaOrResolverValidation, executeValidation, reRender, resolverRef]);\n  const setInternalValues = useCallback((name, value, config, parentFieldName) => {\n    for (const key in value) {\n      const fieldName = \"\".concat(parentFieldName || name).concat(isArray(value) ? \"[\".concat(key, \"]\") : \".\".concat(key));\n      const field = fieldsRef.current[fieldName];\n\n      if (isObject(value[key])) {\n        setInternalValues(name, value[key], config, fieldName);\n      }\n\n      if (field) {\n        setFieldValue(field, value[key]);\n\n        if (config.shouldDirty) {\n          setDirty(fieldName);\n        }\n\n        if (config.shouldValidate) {\n          trigger(fieldName);\n        }\n      }\n    }\n  }, [trigger, setFieldValue, setDirty]);\n  const setInternalValue = useCallback((name, value, config) => {\n    if (fieldsRef.current[name]) {\n      setFieldValue(fieldsRef.current[name], value);\n      return config.shouldDirty && setDirty(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n    }\n  }, [setDirty, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name, found = true) => {\n    if (!isEmptyObject(watchFieldsHookRef.current)) {\n      for (const key in watchFieldsHookRef.current) {\n        if (watchFieldsHookRef.current[key].has(name) || !watchFieldsHookRef.current[key].size || isNameInFieldArray(fieldArrayNamesRef.current, name)) {\n          watchFieldsHookRenderRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config = {}) {\n    const shouldRender = setInternalValue(name, value, config) || !isPrimitive(value) || isFieldWatched(name);\n    renderWatchedInputs(name);\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    if (config.shouldValidate) {\n      trigger(name);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6({\n      type,\n      target\n    }) {\n      var name, field, error, isBlurEvent, shouldSkipValidation, shouldRender, _yield$resolver, errors, previousFormIsValid;\n\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            name = target ? target.name : '';\n            field = fieldsRef.current[name];\n\n            if (field) {\n              _context6.next = 4;\n              break;\n            }\n\n            return _context6.abrupt(\"return\");\n\n          case 4:\n            isBlurEvent = type === EVENTS.BLUR;\n            shouldSkipValidation = !isOnAll && skipValidation({\n              hasError: !!get(errorsRef.current, name),\n              isOnChange,\n              isBlurEvent,\n              isOnSubmit,\n              isReValidateOnSubmit,\n              isOnBlur,\n              isReValidateOnBlur,\n              isSubmitted: isSubmittedRef.current\n            });\n            shouldRender = setDirty(name) || isFieldWatched(name);\n\n            if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormStateRef.current.touched) {\n              set(touchedFieldsRef.current, name, true);\n              shouldRender = true;\n            }\n\n            if (!shouldSkipValidation) {\n              _context6.next = 11;\n              break;\n            }\n\n            renderWatchedInputs(name);\n            return _context6.abrupt(\"return\", shouldRender && reRender());\n\n          case 11:\n            if (!resolver) {\n              _context6.next = 22;\n              break;\n            }\n\n            _context6.next = 14;\n            return resolver(getFieldValueByName(fieldsRef.current), contextRef.current, validateAllFieldCriteria);\n\n          case 14:\n            _yield$resolver = _context6.sent;\n            errors = _yield$resolver.errors;\n            previousFormIsValid = isValidRef.current;\n            isValidRef.current = isEmptyObject(errors);\n            error = get(errors, name) ? {\n              [name]: get(errors, name)\n            } : {};\n\n            if (previousFormIsValid !== isValidRef.current) {\n              shouldRender = true;\n            }\n\n            _context6.next = 25;\n            break;\n\n          case 22:\n            _context6.next = 24;\n            return validateField(fieldsRef, validateAllFieldCriteria, field);\n\n          case 24:\n            error = _context6.sent;\n\n          case 25:\n            renderWatchedInputs(name);\n\n            if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n              reRender();\n            }\n\n          case 27:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n\n    return function (_x9) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  const validateResolver = useCallback((values = {}) => {\n    const fieldValues = isEmptyObject(defaultValuesRef.current) ? getFieldsValues(fieldsRef.current) : defaultValuesRef.current;\n    resolverRef.current(transformToNestObject(Object.assign(Object.assign({}, fieldValues), values)), contextRef.current, validateAllFieldCriteria).then(({\n      errors\n    }) => {\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    });\n  }, [reRender, validateAllFieldCriteria, resolverRef]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => {\n    findRemovedFieldAndRemoveListener(fieldsRef.current, handleChangeRef.current, field, unmountFieldsStateRef, shouldUnregister, forceDelete);\n  }, [shouldUnregister]);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field && (!isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) || forceDelete)) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister) {\n        [errorsRef, touchedFieldsRef, dirtyFieldsRef, defaultValuesAtRenderRef].forEach(data => unset(data.current, field.ref.name));\n        [fieldsWithValidationRef, validFieldsRef, watchFieldsRef].forEach(data => data.current.delete(field.ref.name));\n\n        if (readFormStateRef.current.isValid || readFormStateRef.current.touched) {\n          reRender();\n\n          if (resolverRef.current) {\n            validateResolver();\n          }\n        }\n      }\n    }\n  }, [reRender, validateResolver, removeFieldEventListener, resolverRef]);\n\n  function clearErrors(name) {\n    if (name) {\n      (isArray(name) ? name : [name]).forEach(inputName => unset(errorsRef.current, inputName));\n    } else {\n      errorsRef.current = {};\n    }\n\n    reRender();\n  }\n\n  function setError(name, error) {\n    isValidRef.current = false;\n    set(errorsRef.current, name, Object.assign(Object.assign({}, error), {\n      ref: (fieldsRef.current[name] || {}).ref\n    }));\n    reRender();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? watchFieldsHookRef.current[watchId] : watchFieldsRef.current;\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef.current, fieldNames);\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    if (isUndefined(watchId)) {\n      isWatchAllRef.current = true;\n    }\n\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    (isArray(name) ? name : [name]).forEach(fieldName => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\n  }\n\n  function registerFieldsRef(ref, validateOptions = {}) {\n    if (!ref.name) {\n      // eslint-disable-next-line no-console\n      return console.warn('Missing name @', ref);\n    }\n\n    const name = ref.name,\n          type = ref.type,\n          value = ref.value;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? isArray(field.options) && unique(field.options).find(option => {\n      return value === option.ref.value && option.ref === ref;\n    }) : ref === field.ref)) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...unique(field && field.options || []), {\n          ref,\n          mutationWatcher\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), {\n        mutationWatcher\n      });\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(unmountFieldsStateRef.current[name]);\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = isEmptyUnmountFields ? get(defaultValuesRef.current, name) : unmountFieldsStateRef.current[name];\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, validateAllFieldCriteria, field).then(error => {\n          const previousFormIsValid = isValidRef.current;\n          isEmptyObject(error) ? validFieldsRef.current.add(name) : isValidRef.current = false;\n\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? getFieldValue(fields, name) : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners({\n        field: isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field,\n        isRadioOrCheckbox: isRadioOrCheckbox || isSelectInput(ref),\n        handleChange: handleChangeRef.current\n      });\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldsRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldsRef(refOrValidationOptions, rules);\n      } else {\n        return ref => ref && registerFieldsRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback(callback => /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(e) {\n      var fieldErrors, fieldValues, _yield$resolverRef$cu2, errors, values, _i2, _Object$values, field, name, fieldError;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (e) {\n              e.preventDefault();\n              e.persist();\n            }\n\n            fieldErrors = {};\n            fieldValues = Object.assign(Object.assign({}, unmountFieldsStateRef.current), getFieldsValues(fieldsRef.current));\n\n            if (readFormStateRef.current.isSubmitting) {\n              isSubmittingRef.current = true;\n              reRender();\n            }\n\n            _context7.prev = 4;\n\n            if (!resolverRef.current) {\n              _context7.next = 16;\n              break;\n            }\n\n            _context7.next = 8;\n            return resolverRef.current(transformToNestObject(fieldValues), contextRef.current, validateAllFieldCriteria);\n\n          case 8:\n            _yield$resolverRef$cu2 = _context7.sent;\n            errors = _yield$resolverRef$cu2.errors;\n            values = _yield$resolverRef$cu2.values;\n            errorsRef.current = errors;\n            fieldErrors = errors;\n            fieldValues = values;\n            _context7.next = 28;\n            break;\n\n          case 16:\n            _i2 = 0, _Object$values = Object.values(fieldsRef.current);\n\n          case 17:\n            if (!(_i2 < _Object$values.length)) {\n              _context7.next = 28;\n              break;\n            }\n\n            field = _Object$values[_i2];\n\n            if (!field) {\n              _context7.next = 25;\n              break;\n            }\n\n            name = field.ref.name;\n            _context7.next = 23;\n            return validateField(fieldsRef, validateAllFieldCriteria, field);\n\n          case 23:\n            fieldError = _context7.sent;\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              validFieldsRef.current.delete(name);\n            } else if (fieldsWithValidationRef.current.has(name)) {\n              validFieldsRef.current.add(name);\n            }\n\n          case 25:\n            _i2++;\n            _context7.next = 17;\n            break;\n\n          case 28:\n            if (!(isEmptyObject(fieldErrors) && Object.keys(errorsRef.current).every(name => Object.keys(fieldsRef.current).includes(name)))) {\n              _context7.next = 35;\n              break;\n            }\n\n            errorsRef.current = {};\n            reRender();\n            _context7.next = 33;\n            return callback(transformToNestObject(fieldValues), e);\n\n          case 33:\n            _context7.next = 37;\n            break;\n\n          case 35:\n            errorsRef.current = Object.assign(Object.assign({}, errorsRef.current), fieldErrors);\n\n            if (shouldFocusError && isWeb) {\n              focusOnErrorField(fieldsRef.current, fieldErrors);\n            }\n\n          case 37:\n            _context7.prev = 37;\n            isSubmittedRef.current = true;\n            isSubmittingRef.current = false;\n            submitCountRef.current = submitCountRef.current + 1;\n            reRender();\n            return _context7.finish(37);\n\n          case 43:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7, null, [[4,, 37, 43]]);\n    }));\n\n    return function (_x10) {\n      return _ref8.apply(this, arguments);\n    };\n  }(), [isWeb, reRender, resolverRef, shouldFocusError, validateAllFieldCriteria]);\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields\n  }) => {\n    fieldsRef.current = {};\n\n    if (!errors) {\n      errorsRef.current = {};\n    }\n\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n\n    if (!isDirty) {\n      isDirtyRef.current = false;\n    }\n\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = {};\n    }\n\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValues.current = {};\n    unmountFieldsStateRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n\n  const reset = (values, omitResetState = {}) => {\n    if (isWeb) {\n      for (var _i3 = 0, _Object$values2 = Object.values(fieldsRef.current); _i3 < _Object$values2.length; _i3++) {\n        const field = _Object$values2[_i3];\n\n        if (field) {\n          const ref = field.ref,\n                options = field.options;\n          const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    if (values) {\n      defaultValuesRef.current = values;\n    }\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    resetRefs(omitResetState);\n    reRender();\n  };\n\n  const getValue = name => getFieldValue(fieldsRef.current, name);\n\n  function getValues(payload) {\n    const fields = fieldsRef.current;\n\n    if (isString(payload)) {\n      return getValue(payload);\n    }\n\n    if (isArray(payload)) {\n      return payload.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: getValue(name)\n      }), {});\n    }\n\n    return transformToNestObject(getFieldsValues(fields));\n  }\n\n  useEffect(() => {\n    isUnMount.current = false;\n    return () => {\n      isUnMount.current = true;\n      fieldsRef.current && process.env.NODE_ENV === 'production' && Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n\n  const formState = {\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isDirty: isDirtyRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isValidRef.current\n  };\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [reRender, setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = Object.assign(Object.assign(Object.assign({\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    reRender\n  }, resolver ? {\n    validateSchemaIsValid: validateResolver\n  } : {}), {\n    mode: {\n      isOnBlur,\n      isOnSubmit,\n      isOnChange\n    },\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnSubmit\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    isSubmittedRef,\n    readFormStateRef,\n    defaultValuesRef,\n    unmountFieldsStateRef\n  }), commonProps);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nconst appendId = (value, keyName) => Object.assign({\n  [keyName]: generateId()\n}, isObject(value) ? value : {\n  value\n});\n\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map(value => appendId(value, keyName));\n\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\n\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return unique(data);\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => isArray(data) ? data.splice(to, 0, data.splice(from, 1)[0]) : [];\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(isArray(value) ? value : [value || null]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(isArray(value) ? value : [value || null]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => isArray(value) ? Array(value.length).fill(null) : null;\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    const object = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nconst filterBooleanArray = value => isArray(value) ? value.map(mapValueToBoolean).flat() : mapValueToBoolean(value);\n\nconst useFieldArray = ({\n  control,\n  name,\n  keyName = 'id'\n}) => {\n  const methods = useFormContext();\n  const focusIndexRef = useRef(-1);\n\n  const _ref9 = control || methods.control,\n        isWatchAllRef = _ref9.isWatchAllRef,\n        resetFieldArrayFunctionRef = _ref9.resetFieldArrayFunctionRef,\n        fieldArrayNamesRef = _ref9.fieldArrayNamesRef,\n        reRender = _ref9.reRender,\n        fieldsRef = _ref9.fieldsRef,\n        defaultValuesRef = _ref9.defaultValuesRef,\n        removeFieldEventListener = _ref9.removeFieldEventListener,\n        errorsRef = _ref9.errorsRef,\n        dirtyFieldsRef = _ref9.dirtyFieldsRef,\n        isDirtyRef = _ref9.isDirtyRef,\n        touchedFieldsRef = _ref9.touchedFieldsRef,\n        readFormStateRef = _ref9.readFormStateRef,\n        watchFieldsRef = _ref9.watchFieldsRef,\n        validFieldsRef = _ref9.validFieldsRef,\n        fieldsWithValidationRef = _ref9.fieldsWithValidationRef,\n        fieldArrayDefaultValues = _ref9.fieldArrayDefaultValues,\n        validateSchemaIsValid = _ref9.validateSchemaIsValid,\n        renderWatchedInputs = _ref9.renderWatchedInputs;\n\n  let shouldRender;\n\n  const getDefaultValues = () => [...get(fieldArrayDefaultValues.current[getFieldArrayParentName(name)] ? fieldArrayDefaultValues.current : defaultValuesRef.current, name, [])];\n\n  const memoizedDefaultValues = useRef(getDefaultValues());\n\n  const _useState3 = useState(mapIds(memoizedDefaultValues.current, keyName)),\n        _useState4 = _slicedToArray(_useState3, 2),\n        fields = _useState4[0],\n        setField = _useState4[1];\n\n  const _useState5 = useState(false),\n        _useState6 = _slicedToArray(_useState5, 2),\n        isDeleted = _useState6[0],\n        setIsDeleted = _useState6[1];\n\n  const allFields = useRef(fields);\n  const isNameKey = isKey(name);\n  allFields.current = fields;\n\n  if (isNameKey) {\n    fieldArrayDefaultValues.current[name] = memoizedDefaultValues.current;\n  }\n\n  const appendValueWithKey = values => values.map(value => appendId(value, keyName));\n\n  const setFieldAndValidState = fieldsValues => {\n    setField(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateSchemaIsValid) {\n      validateSchemaIsValid({\n        [name]: fieldsValues\n      });\n    }\n  };\n\n  const shouldRenderFieldArray = shouldRender => {\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      shouldRender = true;\n    }\n\n    renderWatchedInputs(name);\n    shouldRender && !isWatchAllRef.current && reRender();\n  };\n\n  const resetFields = flagOrFields => {\n    if (readFormStateRef.current.isDirty) {\n      isDirtyRef.current = isUndefined(flagOrFields) || getIsFieldsDifferent(flagOrFields, get(defaultValuesRef.current, name, []));\n    }\n\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n\n  const append = (value, shouldFocus = true) => {\n    shouldRender = false;\n    setFieldAndValidState([...allFields.current, ...(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])]);\n\n    if (readFormStateRef.current.dirtyFields) {\n      dirtyFieldsRef.current[name] = [...(dirtyFieldsRef.current[name] || fillEmptyArray(fields.slice(0, 1))), ...filterBooleanArray(value)];\n      isDirtyRef.current = true;\n      shouldRender = true;\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const prepend$1 = (value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    shouldRender = false;\n    resetFields();\n    setFieldAndValidState(prepend(allFields.current, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = prepend(get(errorsRef.current, name), emptyArray);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = prepend(touchedFieldsRef.current[name], emptyArray);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      dirtyFieldsRef.current[name] = prepend(dirtyFieldsRef.current[name], filterBooleanArray(value));\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    shouldRender = false;\n    resetFields(removeArrayAt(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(removeArrayAt(allFields.current, index));\n    setIsDeleted(true);\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = removeArrayAt(get(errorsRef.current, name), index);\n\n      if (!unique(errorsRef.current[name]).length) {\n        delete errorsRef.current[name];\n      }\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = removeArrayAt(touchedFieldsRef.current[name], index);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      dirtyFieldsRef.current[name] = removeArrayAt(dirtyFieldsRef.current[name], index);\n\n      if (!dirtyFieldsRef.current[name].length) {\n        delete dirtyFieldsRef.current[name];\n      }\n\n      shouldRender = true;\n    }\n\n    if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n\n        if (!isFound) {\n          continue;\n        }\n\n        for (const key in fields[fieldIndex]) {\n          const currentFieldName = \"\".concat(name, \"[\").concat(fieldIndex, \"].\").concat(key);\n\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(currentFieldName);\n            fieldsWithValidationRef.current.delete(currentFieldName);\n          } else {\n            const previousFieldName = \"\".concat(name, \"[\").concat(fieldIndex - 1, \"].\").concat(key);\n\n            if (validFieldsRef.current.has(currentFieldName)) {\n              validFieldsRef.current.add(previousFieldName);\n            }\n\n            if (fieldsWithValidationRef.current.has(currentFieldName)) {\n              fieldsWithValidationRef.current.add(previousFieldName);\n            }\n          }\n        }\n      }\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const insert$1 = (index, value, shouldFocus = true) => {\n    shouldRender = false;\n    const emptyArray = fillEmptyArray(value);\n    resetFields(insert(getFieldValueByName(fieldsRef.current, name), index));\n    setFieldAndValidState(insert(allFields.current, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n\n    if (isArray(get(errorsRef.current, name))) {\n      errorsRef.current[name] = insert(get(errorsRef.current, name), index, emptyArray);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      touchedFieldsRef.current[name] = insert(touchedFieldsRef.current[name], index, emptyArray);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      dirtyFieldsRef.current[name] = insert(dirtyFieldsRef.current[name], index, filterBooleanArray(value));\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    shouldRender = false;\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    swapArrayAt(allFields.current, indexA, indexB);\n    setFieldAndValidState([...allFields.current]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      swapArrayAt(get(errorsRef.current, name), indexA, indexB);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      swapArrayAt(touchedFieldsRef.current[name], indexA, indexB);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      swapArrayAt(dirtyFieldsRef.current[name], indexA, indexB);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const move = (from, to) => {\n    shouldRender = false;\n    const fieldValues = getFieldValueByName(fieldsRef.current, name);\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    moveArrayAt(allFields.current, from, to);\n    setFieldAndValidState([...allFields.current]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      moveArrayAt(get(errorsRef.current, name), from, to);\n    }\n\n    if (readFormStateRef.current.touched && touchedFieldsRef.current[name]) {\n      moveArrayAt(touchedFieldsRef.current[name], from, to);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && dirtyFieldsRef.current[name]) {\n      moveArrayAt(dirtyFieldsRef.current[name], from, to);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setField(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(() => {\n    if (isNameKey && isDeleted && fieldArrayDefaultValues.current[name] && fields.length < fieldArrayDefaultValues.current[name].length) {\n      fieldArrayDefaultValues.current[name].pop();\n    }\n\n    if (isWatchAllRef && isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      var _iterator = _createForOfIteratorHelper(watchFieldsRef.current),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const watchField = _step.value;\n\n          if (watchField.startsWith(name)) {\n            reRender();\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(\"\".concat(name, \"[\").concat(focusIndexRef.current, \"]\")) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name, fieldArrayDefaultValues, isDeleted, isNameKey, reRender, fieldsRef, watchFieldsRef, isWatchAllRef]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n    fieldArrayNames.add(name);\n    resetFunctions[name] = reset;\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNames.delete(name);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [fields, name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\n\nfunction useWatch({\n  control,\n  name,\n  defaultValue\n}) {\n  const methods = useFormContext();\n\n  const _ref10 = control || methods.control,\n        watchFieldsHookRef = _ref10.watchFieldsHookRef,\n        watchFieldsHookRenderRef = _ref10.watchFieldsHookRenderRef,\n        watchInternal = _ref10.watchInternal,\n        defaultValuesRef = _ref10.defaultValuesRef;\n\n  const _useState7 = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue),\n        _useState8 = _slicedToArray(_useState7, 2),\n        value = _useState8[0],\n        setValue = _useState8[1];\n\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  const nameRef = useRef(name);\n  const updateWatchValue = useCallback(() => setValue(watchInternal(nameRef.current, defaultValueRef.current, idRef.current)), [setValue, watchInternal, defaultValueRef, nameRef, idRef]);\n  useEffect(() => {\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = watchFieldsHookRenderRef.current;\n    const watchFieldsHook = watchFieldsHookRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(nameRef.current, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [nameRef, updateWatchValue, watchFieldsHookRenderRef, watchFieldsHookRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = (event, isCheckboxInput) => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isCheckboxInput || isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nconst Controller = _a => {\n  var name = _a.name,\n      rules = _a.rules,\n      as = _a.as,\n      render = _a.render,\n      defaultValue = _a.defaultValue,\n      control = _a.control,\n      onFocus = _a.onFocus,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const methods = useFormContext();\n\n  const _ref11 = control || methods.control,\n        defaultValuesRef = _ref11.defaultValuesRef,\n        setValue = _ref11.setValue,\n        register = _ref11.register,\n        unregister = _ref11.unregister,\n        errorsRef = _ref11.errorsRef,\n        trigger = _ref11.trigger,\n        _ref11$mode = _ref11.mode,\n        isOnSubmit = _ref11$mode.isOnSubmit,\n        isOnBlur = _ref11$mode.isOnBlur,\n        isOnChange = _ref11$mode.isOnChange,\n        _ref11$reValidateMode = _ref11.reValidateMode,\n        isReValidateOnBlur = _ref11$reValidateMode.isReValidateOnBlur,\n        isReValidateOnSubmit = _ref11$reValidateMode.isReValidateOnSubmit,\n        isSubmittedRef = _ref11.isSubmittedRef,\n        touchedFieldsRef = _ref11.touchedFieldsRef,\n        readFormStateRef = _ref11.readFormStateRef,\n        reRender = _ref11.reRender,\n        fieldsRef = _ref11.fieldsRef,\n        fieldArrayNamesRef = _ref11.fieldArrayNamesRef,\n        unmountFieldsStateRef = _ref11.unmountFieldsStateRef,\n        formState = _ref11.formState;\n\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(unmountFieldsStateRef.current[name]) && isNotFieldArray ? unmountFieldsStateRef.current[name] : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const _useState9 = useState(getInitialValue()),\n        _useState10 = _slicedToArray(_useState9, 2),\n        value = _useState10[0],\n        setInputStateValue = _useState10[1];\n\n  const valueRef = useRef(value);\n  const isCheckboxInput = isBoolean(value);\n  const onFocusRef = useRef(onFocus);\n  const isSubmitted = isSubmittedRef.current;\n\n  const shouldValidate = () => !skipValidation({\n    hasError: !!get(errorsRef.current, name),\n    isOnBlur,\n    isOnSubmit,\n    isOnChange,\n    isReValidateOnBlur,\n    isReValidateOnSubmit,\n    isSubmitted\n  });\n\n  const commonTask = event => {\n    const data = getInputValue(event[0], isCheckboxInput);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = useCallback(() => {\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n\n        get() {\n          return valueRef.current;\n        }\n\n      }), rules);\n    }\n  }, [fieldsRef, rules, name, onFocusRef, register]);\n  useEffect(() => () => {\n    !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(() => {\n    registerField();\n  }, [registerField]); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touchedFieldsRef.current, name)) {\n      set(touchedFieldsRef.current, name, true);\n      reRender();\n    }\n\n    if (isOnBlur || formState.isSubmitted && isReValidateOnBlur) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event) => setValue(name, commonTask(event), {\n    shouldValidate: shouldValidate(),\n    shouldDirty: true\n  });\n\n  const props = Object.assign(Object.assign(Object.assign({}, rest), {\n    onChange,\n    onBlur\n  }), {\n    [isCheckboxInput ? 'checked' : VALUE]: value\n  });\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render({\n    onChange,\n    onBlur,\n    value\n  }) : null;\n};\n\nexport { Controller, FormContext, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":null,"metadata":{},"sourceType":"module"}